---
title: Plugins
description: Extend Callapi's functionality with plugins
---

Plugins allow you to extend `CallApi` with extra functionality.

## Creating a Plugin

You can use the `definePlugin` helper to provide type safety when creating a plugin:

```ts twoslash title="plugins.ts"
import { definePlugin, createFetchClient } from "@zayne-labs/callapi";

const envPlugin = definePlugin({
	id: "env-plugin",
	name: "Environment Plugin",
	description: "A plugin that adds environment-specific headers to requests",
	version: "1.0.0",

	init: ({ request }) => {
		const env = process.env.NODE_ENV ?? "development";

		const clientInfo = {
			platform: typeof window !== "undefined" ? "browser" : "node",
			timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
		};

		const updatedRequest = {
			...request,
			headers: {
				...request.headers,
				"X-Environment": env,
				"X-Client-Platform": clientInfo.platform,
				"X-Client-Timezone": clientInfo.timezone,
			},
		};

		return {
			request: updatedRequest,
		};
	},
});

const callBackendApi = createFetchClient({
	baseURL: "http://localhost:3000",
	plugins: [envPlugin],
});
```

Or alternatively, use TypeScript's `satisfies` keyword with `CallApiPlugin` type:

```ts twoslash title="plugins.ts"
import type { CallApiPlugin } from "@zayne-labs/callapi";

const envPlugin = {
	id: "env-plugin",
	name: "Environment Plugin",
	description: "Adds environment-specific headers to requests",
	version: "1.0.0",

	init: ({ request }) => {
		const env = process.env.NODE_ENV || "development";
		const clientInfo = {
			platform: typeof window !== "undefined" ? "browser" : "node",
			timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
		};

		return {
			request: {
				...request,
				headers: {
					...request.headers,
					"X-Environment": env,
					"X-Client-Platform": clientInfo.platform,
					"X-Client-Timezone": clientInfo.timezone,
				},
			},
		};
	},
} satisfies CallApiPlugin;
```

### Init Function

The init function is called before the request is made and any of CallApi's internal functions are called. It takes the url, options, and request as arguments and is expected to return the modified url, options and request if necessary.

It can return:

- `void`: Make no changes
- An object to modify the request:
   ```ts
   {
     url?: string;              // Modified URL
     options?: CallApiOptions;  // Modified options
     request: RequestOptions;   // Modified request config
   }
   ```

## Using Plugins

Add plugins when creating a fetch client:

```ts
const client = createFetchClient({
	plugins: [envPlugin, loggingPlugin],
});
```

Or when making individual requests:

```ts
const { data } = await callApi("/users", {
	plugins: [metricsPlugin],
});
```

## Plugin Execution Order

1. Plugin `init` functions run in the order plugins are added
2. Plugin hooks run before main hooks (those defined in `createFetchClient` or individual requests)
3. Multiple plugin hooks of the same type run based on `mergedHooksExecutionMode`:
   - `sequential`: One after another (default)
   - `parallel`: All at once

## Example: Metrics Plugin

Here's a complete example of a plugin that tracks API metrics:

```ts
const metricsPlugin = definePlugin({
	id: "metrics",
	name: "Metrics Plugin",
	description: "Tracks API response times and success rates",

	init: ({ initURL }) => {
		console.log(`Starting request to ${initURL}`);
		const startTime = performance.now();

		return {
			options: {
				context: { startTime },
			},
		};
	},

	hooks: {
		onSuccess: ({ options }) => {
			const duration = performance.now() - options.context.startTime;
			console.log(`Request completed in ${duration}ms`);
		},

		onError: ({ error, options }) => {
			const duration = performance.now() - options.context.startTime;
			console.error(`Request failed after ${duration}ms:`, error);
		},
	},
});
```
