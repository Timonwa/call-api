---
title: Plugins
description: Extend Callapi's functionality with plugins
---

Plugins allow you to extend `CallApi` with extra functionality.

## Creating a Plugin

You can use the `definePlugin` helper to provide type safety when creating a plugin:

```ts twoslash title="plugins.ts"
import { definePlugin } from "@zayne-labs/callapi";

const authPlugin = definePlugin({
	// Plugin metadata
	id: "auth-plugin",
	name: "Auth Plugin",
	description: "Adds authentication headers to requests",
	version: "1.0.0",

	//Initialize plugin
	init: ({ options, request }) => {
		const token = localStorage.getItem("token");

		return {
			request: {
				...request,
				// headers: {
				// 	...request.headers,
				// 	Authorization: `Bearer ${token}`,
				// },
			},
		};
	},

	// Plugin hooks
	hooks: {
		onResponse: [
			({ response }) => console.log("Status:", response.status),
			({ response }) => console.log("Headers:", response.headers),
		],
		onError: ({ error }) => console.error("Failed:", error),
	},
});
```

Or you just use the `CallApiPlugin` type together with satisfies keyword to achieve the same result:

```

### Init Function

The init function is called before the request is made and any of CallApi's internal functions are called. It takes the url, options, and request as arguments and is expected to return the modified url, options and request if necessary.

```ts
type PluginInitContext = {
	initURL: string; // The request URL
	options: CallApiExtraOptions; // Current options
	request: RequestOptions; // Current request config
};
````

It can return:

- `void`: Make no changes
- An object to modify the request:
   ```ts
   {
     url?: string;              // Modified URL
     options?: CallApiOptions;  // Modified options
     request: RequestOptions;   // Modified request config
   }
   ```

## Using Plugins

Add plugins when creating a fetch client:

```ts
const client = createFetchClient({
	plugins: [authPlugin, loggingPlugin],
});
```

Or when making individual requests:

```ts
const { data } = await callApi("/users", {
	plugins: [metricsPlugin],
});
```

## Plugin Execution Order

1. Plugin `init` functions run in the order plugins are added
2. Plugin hooks run before main hooks (those defined in `createFetchClient` or individual requests)
3. Multiple plugin hooks of the same type run based on `mergedHooksExecutionMode`:
   - `sequential`: One after another (default)
   - `parallel`: All at once

## Example: Metrics Plugin

Here's a complete example of a plugin that tracks API metrics:

```ts
const metricsPlugin = definePlugin({
	id: "metrics",
	name: "Metrics Plugin",
	description: "Tracks API response times and success rates",

	init: ({ initURL }) => {
		console.log(`Starting request to ${initURL}`);
		const startTime = performance.now();

		return {
			options: {
				context: { startTime },
			},
		};
	},

	hooks: {
		onSuccess: ({ options }) => {
			const duration = performance.now() - options.context.startTime;
			console.log(`Request completed in ${duration}ms`);
		},

		onError: ({ error, options }) => {
			const duration = performance.now() - options.context.startTime;
			console.error(`Request failed after ${duration}ms:`, error);
		},
	},
});
```
